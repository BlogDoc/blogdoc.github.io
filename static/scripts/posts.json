[{"0":"the-new-blog-doc.md","1":{"frontmatter":{"title":"The New Blog-Doc","date":"2023/07/23","description":"A tiny flame in the darkness of error","featuredImage":"/static/images/tiny-flame.avif","tags":["Blog-Doc","Hono","Eta","Marked"]},"content":"\r\nIn the vast landscape of Node.js apps, Blog-Doc shines as a tiny flame in the darkness of error.  \r\nIt is a remarkable and unique combination of a Content Management System (CMS) and a Static Site Generator (SSG) built entirely with Node.js.<br/>\r\nWhile paying homage to the developers of other Node.js-based Static Site Generators, Blog-Doc sets itself apart by offering unparalleled simplicity and speed.\r\n\r\n## Nota bene\r\n\r\n**The [previous post](/posts/templates) has been retained for demonstration purposes, but its content is no longer relevant to the new version of Blog-Doc.**\r\n\r\nBlog-Doc's latest version proudly employs:\r\n\r\n-   [Hono](https://hono.dev/), small, simple, and ultrafast web framework for the Edges.\r\n-   [Eta](https://eta.js.org/), lightweight, powerful, pluggable embedded JS template engine.\r\n-   [Marked](https://marked.js.org/), Markdown parser and compiler. Built for speed.\r\n\r\n## Motivation & Purpose\r\n\r\nBlog-Doc was born out of a desire to create something truly efficient and straightforward.<br/>\r\nI've realized that existing Static Site Generators often came with unnecessary complexities, resembling gasworks more than elegant solutions.<br/>\r\nBlog-Doc is a passionate response to this challenge, aiming to provide a seamless experience for developers who seek a lightweight, fast, and user-friendly CMS and SSG.\r\n\r\n## Blazing Fast and Simple\r\n\r\nBlog-Doc truly lives up to its name, offering blazing-fast performance and an incredibly simple configuration.<br/>\r\nWith zero code required for configuration, Blog-Doc can be effortlessly set up as both a Node.js CMS and a static site generator.<br/>\r\nIts minimalist approach ensures that your site loads in the blink of an eye, free from any unnecessary functionalities.\r\n\r\n## Design\r\n\r\nBlog-Doc boasts a responsive, elegant, and simple layout. It comes with a ready-to-use template for blogs and documentation, which can be easily customized to suit different designs.\r\n\r\n## Features\r\n\r\nBlog-Doc is packed with a variety of powerful features, making it a versatile and practical tool for developers:\r\n\r\n- Front-end Administration: Easily manage your app directly from the front-end.\r\n- Gallery: Conveniently upload and manage images for your pages and posts.\r\n- Content Management: Create, read, update, and delete pages and posts with ease.\r\n- Paginated Blog: Enjoy a paginated blog with a customizable number of posts per page.\r\n- Markdown Support: Write your content using Markdown for a smooth and efficient writing experience.\r\n- HTML Support: Blog-Doc allows the use of HTML within Markdown for greater flexibility.\r\n- Tags: Organize your content with tags for easy navigation and categorization.\r\n- Featured Images: Assign featured images to your posts and pages for visual appeal.\r\n- Archive and Tags List: Benefit from archive and tags list routes for convenient browsing.\r\n- Titles & Meta Descriptions: Customize titles and meta descriptions for better SEO.\r\n- Drag and Drop Menu: Easily reorder menu links with a simple drag-and-drop interface.\r\n- RSS Feed: Generate an RSS feed for your site to keep your audience updated.\r\n- Sitemap: Automatically generate a sitemap to enhance search engine discoverability.\r\n- Built-in Search: Enjoy a built-in search feature for quick content retrieval.\r\n- Code Highlighting: Utilize highlight.js for elegant code highlighting in your posts.\r\n- IDs for Headings: Automatically generate IDs for H2 to H4 heading tags for easier linking.\r\n- No Hot Reloading: Blog-Doc operates without the need for hot reloading during development.\r\n\r\n## What's Next?\r\n\r\nI have exciting plans for future improvements.<br/>\r\nThe app will continue to evolve and receive updates, it's my personal contribution to the Node.js and Markdown communities.<br/>\r\nFeedback, ideas, and suggestions from the community are warmly welcomed, and Blog-Doc invites developers to explore its potential and customize it for various projects.\r\n\r\n## Conclusion\r\n\r\nBlog-Doc is a remarkable achievement in the world of Node.js CMS and SSGs.<br/>\r\nIts simplicity, speed, and powerful features make it a standout choice for developers seeking a lightweight and efficient solution.<br/>\r\nWhether used as a CMS on a Node.js server or deployed as a static site, Blog-Doc promises an enjoyable and productive experience.\r\n\r\nBuilt with love and passion by [LebCit](https://lebcit.github.io/), Blog-Doc stands as a testament to the boundless possibilities of Node.js and Markdown.<br/>\r\nEmbrace the simplicity and embark on a journey of creating delightful content with Blog-Doc.\r\n\r\nHappy coding!\r\n"}},{"0":"templates.md","1":{"frontmatter":{"title":"Templates","date":"2022/11/13","description":"Using EJS for specific pages","featuredImage":"/static/images/templates.avif","tags":["Blog-Doc","Templates","Server-Side"]},"content":"You may ask yourself the reason for a third option of files since we already can create posts and pages in Markdown. Well the reason is that a template can do much more than a Markdown file...<br />\r\nA template file have more capabilities and can render a totally different architecture and design than the predefined ones for a Markdown file.<br />\r\nI intend to make templates editable from the front-end like pages and posts, but not in a near future...\r\n\r\n## Nota bene\r\n\r\n**This post has been retained for demonstration purposes, but its content is no longer relevant to the [new version of Blog-Doc](/posts/the-new-blog-doc).**\r\n\r\n## Capabilities & Security\r\n\r\nA simple example would be to create a contact form, this would take a serious amount of data objects to be passed in the front-matter of a Markdown file as well as in the route where it would be rendered, all of this without forgetting the serious security risks of directly parsing sensitive data to HTML...\r\n\r\n## Architecture & Design\r\n\r\nBlog-Doc's architecture parses Markdown content to HTML which is injected into EJS templates that are rendered on routes matching the Markdown's file name.  \r\nThe design is obviously at the templates' level. We can pass personalized CSS for a post or a page directly from the Markdown file, but structuring a whole web page from Markdown would be a time killer...  \r\nThis is why we use a templating language, EJS in Blog-Doc, to generate our final HTML markup with the power of plain JavaScript.  \r\nAnother advantage is that we could completely change the design of a site for a particular page to whatever we like with a template, but this would result in a labyrinthine system if we try to achieve it from a Markdown file...\r\n\r\n## How to use a template?\r\n\r\nTo use a template file, head over to the **templates** folder under the **views** folder and create in there an `.ejs` file.  \r\nYou can name it whatever you like. As an example : `my-template.ejs`\r\nNow paste the following block of code:\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\t<head>\r\n\t\t<%# Metadata %>\r\n\t\t<meta charset=\"UTF-8\" />\r\n\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\r\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n\t\t<meta name=\"description\" content=\"A DESCRIPTION OF YOUR EJS TEMPLATE\" />\r\n\r\n\t\t<%# Title %>\r\n\t\t<title>Blog-Doc | THE TITLE OF YOUR EJS TEMPLATE</title>\r\n\r\n\t\t<%# Pure.css %>\r\n\t\t<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css\" />\r\n\t\t<%# Pure.css grids. Not necessary if you don't want to use it ! %>\r\n\t\t<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/grids-responsive-min.css\" />\r\n\r\n\t\t<link rel=\"shortcut icon\" href=\"/icons/favicon.ico\" type=\"image/x-icon\" />\r\n\t\t<link rel=\"stylesheet\" href=\"/css/styles.min.css\" />\r\n\t</head>\r\n\t<body>\r\n\t\t<div id=\"layout\">\r\n\t\t\t<%- include('../components/menu') %>\r\n\t\t\t<div id=\"main\">\r\n\t\t\t\t<%# Page header %>\r\n\t\t\t\t<div class=\"header\">\r\n\t\t\t\t\t<h1>THE TITLE OF YOUR EJS TEMPLATE</h1>\r\n\t\t\t\t\t<h2>A DESCRIPTION OF YOUR EJS TEMPLATE</h2>\r\n\t\t\t\t</div>\r\n\t\t\t\t<%# Page content %>\r\n\t\t\t\t<div class=\"content\">\r\n\t\t\t\t\tTHE CONTENT OF YOUR EJS TEMPLATE\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\tYOU CAN USE PLAIN HTML INSIDE AN EJS FILE\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<%- include('../components/footer') %>\r\n\t</body>\r\n</html>\r\n```\r\n\r\nReplace the values of the description `<meta>` tag, the `<title>` tag and the headers inside `<div class=\"header\">` by the appropriate ones for your template.  \r\nCreate the desired content Inside the `<div class=\"content\">`.  \r\nRemember that an `.ejs` file is an `HTML` file supercharged with `JavaScript` powers, meaning that you can use both of them inside it !\r\n\r\nIf your new to EJS, please take the time to read the following articles on my personal blog :\r\n\r\n1. [Templating a Node.js app with EJS](https://lebcit.github.io/posts/templating-a-nodejs-app-with-ejs/)\r\n2. [Improving a Node.js app built with Express and EJS](https://lebcit.github.io/posts/improving-a-nodejs-app-built-with-express-and-ejs/)\r\n\r\nAfter creating your content with a template, you'll be able to add a link to it in the menu or anywhere else that suits your needs.  \r\nThe path of any template that you create will always be : `https://domaine.name/templates/the-template-file-name`.  \r\nIf you created the previous template `my-template.ejs`, you can visit it by clicking on this [link](/templates/my-template).  \r\nOtherwise, Blog-Doc comes with an identical template to the previous code. You can visit [template-file](/templates/template-file) to see it.\r\n\r\n## Conclusion\r\n\r\nIf you followed the articles related to [Blog-Doc](/tags/Blog-Doc) from the beginning till this one, you now have a solid understanding of how everything works under the hood, how the components are displayed on the front-end, how the posts, pages and templates files are rendered on the front-end, and how to use them.\r\n\r\nYou can take Blog-Doc as a prototype and modify it totally to use it with another design and/or another template language.  \r\n**As a proof of concept, I've rebuild [my own blog](https://lebcit.github.io/) with Blog-Doc** ❤️\r\n\r\nI really hope that this app will be useful in any way for a lot of people out there, I'm considering it as my personal contribution to the Node.js, Express, EJS and Markdown communities.\r\n"}},{"0":"posts-and-pages.md","1":{"frontmatter":{"title":"Posts and Pages","date":"2022/11/12","description":"Writing with Markdown","featuredImage":"/static/images/posts-and-pages.avif","tags":["Blog-Doc","Posts","Pages","Server-Side"]},"content":"This post intends to show you how to format a Markdown file to write a post or a page.<br />\r\nThe bellow instructions are applicable if you want to create a post or a page  by yourself.  \r\nOtherwise, head over the [administration page to create](/admin-create) with ease.\r\n\r\nThe most important tool for this task is the IDE, Integrated Development Environment, that you're using. I'm using the one and only [VS Code](https://code.visualstudio.com/), the best IDE in my opinion, with [Prettier](https://prettier.io/) as a well known extension for VS Code [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode). Another great VS Code extension to write in Markdown with ease is [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one). If you are using another IDE, look for an addon/plugin/extension to format your Markdown files while writing a post or a page.\r\n\r\n## Posts\r\n\r\nTo write a post, head to the **posts** folder under the **views** folder and create a new Markdown file. A Markdown file ends with `.md`. If you are using VS Code, I've already setup snippets to generate Markdown front matter in the `.vscode` folder, all you have to do is press `Ctrl+spacebar` and choose the `Blog-Doc Post Frontmatter`, you'll be served with the following block:\r\n\r\n```yaml\r\n---\r\ntitle:\r\ndate: 2022/11/12\r\ndescription:\r\nfeaturedImage: /static/images/\r\ntags: []\r\n---\r\n```\r\n\r\nType the title of your post, the date is automatically generated, give it a short description, put its featured image in the **images** folder under the **static** folder and add the filename after `/static/images/` like `/static/images/an_image.png` or simply link to any image out there like `featuredImage: https://link_to_an_image.com`, and finally tag it with the appropriate keywords in the array of `tags` like `[Development, Node.js, Markdown]`.  \r\nYou should now be able to see your post on the blog and click on it's title or it's _Read the post_ button to access it !\r\n\r\n> _Nota Bene: it's always a good idea to give your post the same file name as it's title for SEO !_\r\n\r\nSo if the title of your post will be **_Just another dev journey story_**, the filename should be `just-another-dev-journey-story.md`.\r\n\r\n## Pages\r\n\r\nThe same logic applies to write a page. Create a Markdown file in the **pages** folder under the **views** folder. Press `Ctrl+spacebar` and choose the `Blog-Doc Page Frontmatter` to get the following snippet:\r\n\r\n```yaml\r\n---\r\ntitle:\r\ndescription:\r\nfeaturedImage: /static/images/\r\n---\r\n```\r\n\r\nAlso, give your page the same file name as it's title for SEO.\r\n\r\nThe page will be rendered on a route matching its file name. As an example, if your page filename is `contact-me.md`, this page would be accessible on a route like `https://domain-name/pages/contact-me`. Then, you'll be able to add a link to your page in the menu or anywhere else that suits your needs.\r\n\r\nA page is generally informational, which is why I didn't add a date or a tags' array to the pages.  \r\nKeep in mind that **everything in Blog-Doc can be modified, adapted or improved**.\r\n\r\n## Notes\r\n\r\nIf you don't use VS Code, copy and paste the post or page front-matter above.  \r\nPlease note that the content of a Markdown file starts two lines after its front-matter!  \r\nYou should leave an empty line between the front-matter and the beginning of your post!  \r\nYou can read more about the Markdown parser used for Blog-Doc by visiting its [repository](https://github.com/markedjs/marked).  \r\nThere is also a [demo page](https://marked.js.org/demo/) for this parser where you can see how it works.\r\n\r\nAnd that's how simply you can write posts and pages using Markdown in Blog-Doc, see you in the next one.\r\n"}},{"0":"the-markdown-route.md","1":{"frontmatter":{"title":"The Markdown route","date":"2022/11/11","description":"Rendering posts and pages","featuredImage":"/static/images/files-route.avif","tags":["Blog-Doc","Server-Side"]},"content":"Under the routes folder lives the `markdownRoute.js` file, it's the most important file of the app, the heart and soul of [Blog-Doc](/posts/what-is-blog-doc). This file looks at two folders sitting under the **views** folder at the same time:\r\n\r\n1. The **posts** folder \r\n2. The **pages** folder\r\n\r\nIt converts the content of the Markdown files in the **posts** and **pages** folders to `HTML` and renders each post and page on a route matching it's filename. If the requested route doesn't match any file name inside those folders, the 404 error page will be displayed.\r\n\r\nTo understand how this file works, please take a look at it, it's pretty well documented.  \r\nYou can also read more about it on my personal blog:\r\n\r\n1. [Markdown blog with EJS](https://lebcit.github.io/posts/markdown-blog-with-ejs/)\r\n2. [Turn a Markdown blog to a simple SSG](https://lebcit.github.io/posts/turn-a-markdown-blog-to-a-simple-ssg/)\r\n\r\nSince everything is explained inside the file itself and in the two articles mentioned above, I'm not going to elaborate further more about it here.\r\n\r\nThat will be all for the rendering of Markdown and EJS files from one end to another, see you in the next one.\r\n"}},{"0":"the-pagination-component.md","1":{"frontmatter":{"title":"The pagination component","date":"2022/11/10","description":"Navigating between blog's pages","featuredImage":"/static/images/pagination-component.avif","tags":["Blog-Doc","Blog","Pagination"]},"content":"One of the functionalities that we have seen in [The Main Route](/posts/the-main-route) is how the blog gets paginated under the hood. In this post, we will talk about the pagination component itself and see how it's rendered on the front-end.\r\n\r\nThe file `pagination.html` in the **components** folder under the **views** folder holds the logic behind the display and the look of the pagination component and is only used by the `index.html` file in the **layouts** folder under the **views** folder on line 72:\r\n\r\n```xml\r\n<!--Start Pagination-->\r\n<% if (it.paginated) { %>\r\n<!--Start include Pagination-->\r\n<%~ include('../components/pagination.html', it) %>\r\n<!--End include Pagination-->\r\n<p class=\"archive-link\">\r\n\tAll the posts can be found in the\r\n\t<a href=\"/posts\">archive</a>\r\n\t📦\r\n</p>\r\n<% } %>\r\n<!--End Pagination-->\r\n```\r\n\r\nUsing Eta as a template engine allows us to write plain `JavaScript` inside an `HTML` file!\r\n\r\nThe `paginated` condition is a passed data object to display or not the pagination component.\r\n\r\nAt the top of the `pagination.html` file, you can find a link to the stylesheet related to this component.\r\n\r\n```xml\r\n<link rel=\"stylesheet\" href=\"/static/styles/pagination.css\" />\r\n```\r\n\r\nThose styles will only be available when the pagination component is displayed. This is very useful to avoid loading unnecessary styles in the app.\r\n\r\nIn [The Main Route](/posts/the-main-route) we have seen that the pagination component will only be displayed for the homepage if the length off all the posts is greater than the [defined number of posts per page](http://localhost:3000/admin-config-site#posts-per-page) for the blog in the settings.\r\n\r\nThat's nice, but how the pagination works on the front-end? How does it know where to go?  \r\nWell, if you look again in `pagination.html` on line 4, you'll see that the pagination for the homepage has a condition:\r\n\r\n```javascript\r\nif (it.firstPage && it.lastPage > 0)\r\n```\r\n\r\nHey ! Where those data objects came from?  \r\nThey also came from the `mainRoute.js` file under the **routes** folder.  \r\nYou can see in there that we have calculated the result of the last page on line 16 with the help of `getPosts` and `paginator` functions which are located under the **functions** folder:\r\n\r\n```javascript\r\n// /routes/mainRoute.js\r\n\r\nimport { getPosts } from \"../functions/blog-doc.js\" // Line 2\r\nimport { paginator } from \"../functions/helpers.js\" // Line 3\r\nconst posts = await getPosts() // Line 4\r\n...\r\n// Paginate all the posts. Set the first page to 1 and X posts per page. | Line 14\r\nconst paginatedPosts = paginator(posts, 1, settings.postsPerPage)\r\n// Get the last page number by removing 1 from the total number of pages. | Line 16\r\nconst lastPage = paginatedPosts.total_pages - 1\r\n```\r\n\r\nAfter that, always in the `mainRoute.js` file, we pass those data objects to the entry route `/`:\r\n\r\n```javascript\r\n// /routes/mainRoute.js\r\n\r\nconst res = eta.render(`themes/${settings.currentTheme}/layouts/base.html`, {\r\n    // Passing Route data\r\n    mainRoute: true,\r\n    firstPage: true,\r\n    // Passing document data\r\n    data: data,\r\n    posts: newestPosts,\r\n    lastPage: lastPage,\r\n    paginated: postsLength > settings.postsPerPage ? true : false, // To display or not the pagination component on the main route.\r\n    // Passing document image data\r\n    postPreviewFallbackImage: settings.postPreviewFallbackImage,\r\n    // Passing needed settings for the template\r\n    siteTitle: settings.siteTitle,\r\n    menuLinks: settings.menuLinks,\r\n    footerCopyright: settings.footerCopyright,\r\n})\r\n```\r\n\r\nSo now, back to our condition in `pagination.html` on line 4, `firstPage` is true for the homepage and we are also checking that the `lastPage` exists as an extra layer of precaution. We can omit the use of this extra layer at this point, but since the pagination component have a particular display for the blog's last page, we need to pass this data object right here to make sure that their will be no future conflict when the `firstPage` is false and the `lastPage` exists. With both conditions acquired, we can display the pagination component for the homepage that will have a link to the **Older Posts**, page 1 of the blog, as well as a left chevron icon linking to the last page of the blog.\r\n\r\nFor the other pages of the blog, the condition is declared on line 25:\r\n\r\n```javascript\r\n// /views/components/pagination.html\r\nif (!it.firstPage)\r\n```\r\n\r\nWe just check that we are not on the first page. Three scenarios can take place:\r\n\r\n1. We are not on the last page but on any page between it and the homepage\r\n2. We are on the last page which is not after the homepage\r\n3. We are on the last page which is just after the homepage\r\n\r\nIn [The Main Route](/posts/the-main-route), we have seen that the function `paginator` gives us some values that we can use to paginate our collection of posts, like the actual page, the previous page and the next page. By using this function in `mainRoute.js` on line 60 and passing it to the dynamic route `\"/page/:actualBlogPage\"` on line 69, we can access those values through the pagination component:\r\n\r\n```javascript\r\n// /routes/mainRoute.js\r\nconst paginatedPostsList = paginator(posts.slice(settings.postsPerPage), actualBlogPage, settings.postsPerPage)) // line 60\r\n...\r\npaginatedPostsList: paginatedPostsList // line 69\r\n```\r\n\r\nSo, for the first scenario, we just have to check that the page we are on have at least one page after it. In other words, we check if their is a `next_page` property returned by the `paginatedPostsList` data object. A simplified explanation would be that we check if there are some previous posts rendered on a page after the page we are on. You can see it in `pagination.html` on line 30 :\r\n\r\n```javascript\r\nif (it.paginatedPostsList.next_page)\r\n```\r\n\r\nSo if this condition is true, we display a link to the last page as well as a link to the previous page.\r\n\r\nThe same logic applies for the page before, but here we solve the last two scenarios together.  \r\nWe know for fact that there is a page before the one we are on, so we just check for the page before where the newer set of posts are rendered on line 52 :\r\n\r\n```javascript\r\nif (it.paginatedPostsList.prev_page)\r\n```\r\n\r\nSo if this condition is true, we display a link to the homepage as well as a link to the next page, and that solves the second scenario.\r\n\r\n> Don't be confused by the switch between previous and next here, remember that the posts are rendered by their publication's dates in descending order, newest to oldest !\r\n\r\nFor the third scenario, where the last page is the first page of the blog, the function will not return a value for the page before it since it's the first one, we check that the `prev_page` property of `paginatedPostsList` is not returned on line 72 with a simple `else` and if this condition is true we display a link to the homepage as well as a link to the previous page who's also the homepage, so 2 links to the homepage in different tastes.\r\n\r\nAnd that's how the pagination component is rendered on the front-end, allowing us to navigate between the blog's pages.\r\n"}},{"0":"the-main-route.md","1":{"frontmatter":{"title":"The Main Route","date":"2022/11/07","description":"The blog behind the curtains","featuredImage":"/static/images/the-main-route.avif","tags":["Blog-Doc","Blog","Server-Side"]},"content":"The` mainRoute.js` file, under the **routes** folder, is where all the functionalities of the blog are defined. It collects, paginates and displays, all the Markdown files in the **posts** folder under the **views** folder.\r\n\r\nThis file uses two functions to get the posts and paginate them :\r\n\r\n1. `import { getPosts } from \"../functions/blog-doc.js\"`\r\n2. `import { paginator } from \"../functions/helpers.js\"`\r\n\r\nTo understand how `getPosts` works, you should read [Markdown blog with EJS](https://lebcit.github.io/posts/markdown-blog-with-ejs/) who’s very important to understand the logic behind the process of writing in Markdown and rendering it on the front-end.  \r\nOn the other hand, the second one is a pagination function. There are a lot of modules to accomplish the desired output, one of the most popular is [Paginator](https://www.npmjs.com/package/paginator) but I didn't want to add another module to this app for a simple task nor reinvent the wheel, so I did a little research to find a ready made pagination that suits my needs and found it while reading the [Easiest Way to Paginate an Array in JavaScript](https://shouts.dev/articles/easiest-way-to-paginate-an-array-in-javascript).\r\n\r\nWith both functions ready to spin, the only task left was some logic.  \r\nSince I decided to have the blog on the entry route `/`, and paginate it with a maximum of the [defined number of posts per page](/admin-config-site#posts-per-page), I just had to do the following steps :\r\n\r\n1. get the newest **X** posts from the array of posts and display them on the homepage\r\n2. get the rest of them and display them with a pagination of **X** posts per page\r\n3. make the pagination available only if the blog have more than **X** posts\r\n\r\n**1-** The first step is pretty easy, just slice out the newest five posts:\r\n\r\n```javascript\r\n// /routes/mainRoute.js\r\n\r\n// Paginate all the posts. Set the first page to 1 and X posts per page. | Line 14\r\nconst paginatedPosts = paginator(posts, 1, settings.postsPerPage)\r\n// Get the first X posts. | Line 15\r\nconst newestPosts = paginatedPosts.data\r\n```\r\n\r\nAfter acquiring those ones, we render them on the entry route `/` via `base.html` in the **layouts** folder under the **views** folder.  \r\nTo know if the first page should be paginated or not, we pass a data object that will display the pagination component only if the length off all the posts is greater than **X**:\r\n\r\n```javascript\r\n// /routes/mainRoute.js\r\n\r\n// Get the total number of posts. | Line 17\r\nconst postsLength = paginatedPosts.total\r\n...\r\n\r\n// To display or not the pagination component on the main route. | Line 34\r\npaginated: postsLength > settings.postsPerPage ? true : false,\r\n```\r\n\r\n**2-** The second step is a little bit trickier because it's not only a matter of slicing out the rest of the posts. We have to slice them out, _dynamically_ define the current page for each set once paginated, paginate them by a maximum of **X** posts per page. This is where the `paginator` function steps in to achieve this goal and returns the actual page, the previous page, the next page, the sliced posts' total, the total of the pages and the sliced posts themselves. We use this function in `mainRoute.js` to accomplish this task on line 60:\r\n\r\n```javascript\r\n// Paginated array from the list of posts without the newest X posts\r\nconst paginatedPostsList = paginator(posts.slice(settings.postsPerPage), actualBlogPage, settings.postsPerPage)\r\n```\r\n\r\n`actualBlogPage` is a parameter in the dynamic route `\"/page/:actualBlogPage\"` defined on line 58:\r\n\r\n```javascript\r\n// Dynamic page number\r\nconst actualBlogPage = c.req.param(\"actualBlogPage\")\r\n```\r\n\r\nWith this in place, the rest of the posts are now paginated in sets of **X**, we use `index.html` to render them on the dynamic route mentioned above and make sure to display the pagination component on each page coming after the homepage by passing a paginated data object on line 71:\r\n\r\n```javascript\r\npaginated: true\r\n```\r\n\r\n**3-** The third step is taken care off in the first step for the homepage and in the second step for each page after the homepage.\r\n\r\nThat's how the blog is getting displayed from behind the curtains to the stage, see you in the next one.\r\n"}},{"0":"archive-and-tags.md","1":{"frontmatter":{"title":"Archive and tags","date":"2022/10/20","description":"Archive and tags pages","featuredImage":"/static/images/archive-and-tags.webp","tags":["Archive","Tags","Blog-Doc"]},"content":"The archive and tags pages are very similar to the blog as mentioned before, except that they have no pagination. The archive is a reversed chronological list of all the posts in the blog, while the tags is an alphabetical ordered list of all the tags used in all the posts with the number of occurrence for each tag.  \r\nIn this post, we'll explore how those pages work behind the scene aka server-side.\r\n\r\n## Archive route\r\n\r\nUnder the **routes** folder, the first file is `archiveRoute.js`. This tiny file collects all the posts and displays them on the `/posts` route using the `base.html` template located in the **layouts** folder under the **views** folder.\r\n\r\nTo understand the archive route file, you'll have to read the following posts :\r\n\r\n1. [Express global router for a DRY code](https://lebcit.github.io/posts/express-global-router-for-a-dry-code/)\r\n2. [Markdown blog with EJS](https://lebcit.github.io/posts/markdown-blog-with-ejs/)\r\n\r\nThe first post shoes us how to parse an express router to a global router variable. The second one is **very important** to understand the logic behind the process of writing in Markdown and rendering it on the front-end.\r\n\r\n### Modifying archive's route\r\n\r\nTo modify the route on which the list of all the posts is displayed, you just have to change `/posts` on line 11 inside `archiveRoute.js` to whatever suits you. As an example, you can change it to `/archive` and the list will now be available on this route instead of the previous one.\r\n\r\n> _Nota Bene: whenever you make a change, always check through the whole app for changes to be made according to the one you're making !_\r\n\r\n## Tags route\r\n\r\nUnder the **routes** folder, the last file is `tagsRoute.js`. This file has 2 tasks:\r\n\r\n1. Display all the tags in the blog's posts\r\n2. Display all the posts for a particular tag\r\n\r\nThe first task is accomplished by a function defined in `blog-doc.js` under the **functions** folder, that creates an array of the tags from all the posts and sort them alphabetically then count the occurrence of each tag in this tags' array and return the result as an object.  \r\nThe function is imported to `tagsRoute.js` on line 2:\r\n\r\n```\r\nimport { postsByTagCount, ... } from \"../functions/blog-doc.js\"\r\n```\r\n\r\nThe function is then passed to the `/tags` route, `posts: await postsByTagCount()`, where we loop through the resulting object in `postsByTagCount.html` on line 2 :\r\n\r\n```\r\nfor (const property in it.posts)\r\n```\r\n\r\nThen we check inside the loop, on line 4, if each tag exists and it's value is greater than 0, to avoid displaying a null tag in the list of tags if one or more post have no tag(s) :\r\n\r\n```\r\nif (property !== \"null\" && property !== \"undefined\")\r\n```\r\n\r\n### Tag route\r\n\r\nThe second task, leading to the display of all the posts for a particular tag, begins with a simple function living in `blog-doc.js` under the **functions** folder. This function, with a `(tag)` parameter, filters the posts to retrieve an array of post(s) including the requested tag, otherwise it returns an empty array.  \r\nThe function is imported in `tagsRoute.js` on line 5 :\r\n\r\n```\r\nimport { ..., postsByTagList } from \"../functions/blog-doc.js\"\r\n```\r\n\r\nThis function is used with the requested parameter (the requested tag) on line 31 inside the dynamic route `\"/tags/:tag\"` :\r\n\r\n```\r\nconst tag = c.req.param(\"tag\")\r\nconst postsByTag = await postsByTagList(tag)\r\n```\r\n\r\nFinally `postsByTag` is passed through the dynamic route as a data object :\r\n\r\n```javascript\r\nposts: postsByTag\r\n```\r\n\r\nThis data object, the array of post(s) related to a single tag, is sent to the `base.html` file in the **layout** folder under the **views** folder, where it will be used by the `index.html` file living in the same folder :\r\n\r\n```xml\r\n// index.html | line 3\r\nit.posts.forEach((post, index) => {...})\r\n```\r\n\r\nThe file `index.html` is responsible of the look and feel of each and every post's preview. I'll be talking later on about this file in details.\r\n\r\nA last thing to mention in the dynamic route is that if the returned array is empty, not even one post is related to the requested tag, the 404 error page is rendered.  \r\nTry to hit a tag route that doesn't exists, as an example : [inexistent tag](/tags/INEXISTENTTAG).\r\n\r\n### Modifying the tags route\r\n\r\nModifying the tags route is quite simple, all you have to do is to change the path `/tags` in `tagsRoute.js` on line 11 to whatever you desire.  \r\nIf you change it to `/hashtags`, the list of all available tags will now be displayed on this route instead of the previous one.\r\n\r\n### Modifying tags' dynamic route\r\n\r\nThe route of each individual tag is defined by a parameter `/:tag` in the dynamic route `\"/tags/:tag\"`. There is absolutely no need to change the parameter by itself !  \r\nLet's say you changed previously `/tags` to `/hashtags`. To keep some logic, you'll have to make the same modification in the dynamic route to `\"/hashtags/:tag\"`.\r\n\r\n> _Nota Bene: whenever you make a change, always check through the whole app for changes to be made according to the one you're making !_\r\n\r\nThat's all for archive and tags, see you in the next one.\r\n"}},{"0":"the-blog.md","1":{"frontmatter":{"title":"The blog","date":"2022/10/05","description":"How the blog works ?","featuredImage":"/static/images/the-blog.webp","tags":["Blog-Doc","Blog"]},"content":"\r\nThis post is an introduction to the blog design and functionalities. We'll explore how things are related and how they work together. We'll understand what's mandatory for the blog to work properly and what's optional.\r\n\r\n## Blog's design & functionalities\r\n\r\nYou'll notice that the homepage, dedicated to the blog, shares with the archive page and the page of a particular tag almost the same design. They give us a view of existing posts, however their designs are slightly different, only the blog is paginated.\r\n\r\nThe blog sorts your posts by their publication's dates in descending order, newest to oldest, and displays the [defined number of posts](/admin-config-site#posts-per-page) in the settings on each page. **The blog will not be paginated if the number of posts is less than the defined number of posts !**\r\n\r\n## Single post preview\r\n\r\nEach post in the blog is represented by a card like the following one :\r\n\r\n<img class=\"pure-img-responsive\" alt=\"Screenshot of a single post card in the blog\" src=\"/static/images/screenshot-card-blog.png\">\r\n\r\nFirst things first, the design of this card is the work of [Chyno Deluxe](https://codepen.io/ChynoDeluxe) that you can find on his [Blog Cards](https://codepen.io/ChynoDeluxe/pen/bdXeqQ) pen.  \r\nThe card is composed of two parts:\r\n\r\n1. A featured image of the post\r\n2. A brief preview of the post\r\n\r\n**The featured image is optional**. If you don't assign a featured image to a post, a fallback image will be displayed. This fallback image can of course be changed depending on your needs.  \r\nTo change the fallback image :\r\n\r\n1. Upload the desired image to the [gallery](/admin-gallery).\r\n2. And select it in the [post preview fallback image](/admin-config-site#post-preview-fallback-image-select).\r\n\r\n### Publishing date & tag(s)\r\n\r\nWhen the preview of a single post is hovered, a zoom in with a little rotation is applied to the featured image while it gets covered by an overlay.  \r\nThe overlay reveals the publishing date of the post and the tag(s) associated to this post **if any**. Yes, **if any means that you can choose to tag or not any post**, tagging a post is an optional feature while giving it a **publishing date is mandatory**, some logic please!\r\n\r\nThe hovered card will look like the following image:\r\n\r\n<img class=\"pure-img-responsive\" alt=\"Screenshot of a hovered single post card in the blog\" src=\"/static/images/screenshot-card-blog-hovered.png\">\r\n\r\n### Brief preview\r\n\r\nThe right section of the card contains the post's **title**, **description**, first **180 characters**, and a **Read the post** button linking to the post itself, just like it's title.  \r\nWhen this button is hovered, the previous effects are applied and the button expands a little bit to the left, gets a blue background while it's label becomes white and an arrow takes the available space to the right, like the following image:\r\n\r\n<img class=\"pure-img-responsive\" alt=\"Screenshot of a hovered button of a single post card in the blog\" src=\"/static/images/screenshot-card-blog-read-hovered.png\">\r\n\r\n## Pagination\r\n\r\nLike explained previously, the pagination will only work if your blog contains more than the defined number of posts. Once this number exceeded, a pagination will be displayed at the bottom of each blog's page.\r\n\r\nThe homepage will have a pagination to the **Older Posts**, page 1 of the blog, as well as a left chevron icon linking to the last page of the blog.  \r\nThe last page of the blog will have a pagination to the **Newer Posts**, as well as a right chevron icon linking to the first page of the blog.  \r\nIn between, every other page of the blog will have a pagination to the **Older Posts**, the **Newer Posts**, a left chevron icon linking to the last page of the blog and a right chevron icon linking to the first page of the blog.\r\n\r\nThis one ends here, I'll be talking more about the pagination later on.\r\n\r\nSee you in the next one 😉\r\n"}},{"0":"what-is-blog-doc.md","1":{"frontmatter":{"title":"What is Blog-Doc ?","date":"2022/09/30","description":"A brief introduction to Blog-Doc.","featuredImage":"","tags":["Blog-Doc"]},"content":"Blog-Doc is **The Simplest Node.js CMS & SSG**. The CMS (Content Management System) allows the user to CRUD (Create, Read, Update, Delete) and control every aspect of the application **from the front-end** while the SSG (Static Site Generator) build a static site out of the created content !  \r\nBlog-Doc is written in JavaScript ES6, using Eta as a templating language and Markdown to write and format the markup of the generated posts and pages.\r\n\r\n## Motivation\r\n\r\nIn July of this year (2022), I've written some posts on [my personal blog](https://lebcit.github.io/) showing how to create a Node.js app using EJS as a templating language and how to improve it. Then, taking the code a step further, I've showed how to use Markdown to write the app's content, and finally how to turn it into a simple SSG. So I've decided to leverage my own tutorials one more step by creating a super simple CMS & SSG out of them.\r\n\r\n## Name, design & architecture\r\n\r\nI wanted from the beginning something extremely easy to maintain, modify and improve.  \r\nWith this in mind, I asked myself two questions :\r\n\r\n-   what would be the purpose of this application ?\r\n-   how it could be useful in the sea of CMS and SSG ?\r\n\r\nThe answer to both came by responding to a third one :\r\n\r\n-   what do we use mostly the net for ?\r\n\r\nPutting aside personal communication, entertainment of any kind and shopping, we use the net to get data ! We search, read, take notes... The web, in my modest opinion, is a place where people share experience and knowledge with each other. Blogging is the way to express ourselves and spread what we have learned, and documentation is the backbone of any decent application... Therefor, the name **Blog-Doc** was chosen.\r\n\r\nOnce the purpose defined, I had to think about the look and feel of this app.  \r\nAgain, simplicity was the keyword. [Pure.css](https://purecss.io/) docs are a great example, they also provide an identical layout of their own website, lucky me !\r\n\r\nFinally, after acquiring the design, I had to carefully build the app's architecture.  \r\nAs easy as it may sound, you have to think about _the future_! Possibilities are limitless, but by writing essential functionalities for the app and deciding how they should work together and what they should do, the path becomes less cloudy...\r\n\r\nThis one ends here, I'll be talking about some aspects of the design and the architecture later on.\r\n\r\nSee you in the next one 😉"}},{"0":"no-description-or-tags.md","1":{"frontmatter":{"title":"No description or tags","date":"2022/08/26","description":"","featuredImage":"https://c.pxhere.com/photos/6d/4d/galaxy_silhouette_star_night_night_sky-113640.jpg!d","tags":[]},"content":"\r\nThis post is for testing the output of an article that doesn't have a description or even a tag. Everything seems to be okay since the display of the tags and their respective numbers are not affected by the absence of tags in a post on the [Tags](/tags) route.\r\n\r\n## Note\r\n\r\nWhile creating a post, you can leave the `description` and/or the `tags` empty, they will not be render.<vr />\r\nPlease keep in mind that if you are creating a post manually, you **must** add those properties to the front matter of the file and leave them empty like so:\r\n\r\n```\r\n---\r\ntitle: The post title\r\ndate: 2023/09/16\r\ndescription: \r\nfeaturedImage: The path or URL to the post's image\r\ntags: []\r\n---\r\n```\r\n\r\nYou can read more about it under [Posts and Pages](/posts/posts-and-pages)."}},{"0":"excerpt-length.md","1":{"frontmatter":{"title":"Excerpt length","date":"2022/08/12","description":"Testing the excerpt of posts","featuredImage":"https://c2.staticflickr.com/4/3676/12024271573_d266422362_h.jpg","tags":["Excerpt"]},"content":"\r\nIn this post, I'm just trying to type some random text to see if the excerpt length will stop when I reach 180 characters. I also want to see how it looks like when the post is rendered on the frontend.\r\n\r\n## Decision\r\n\r\nI thought that 180 chars are maybe too much for an excerpt but after seeing the output on the post's card in the blog, I now think that I'll keep it the way it is.\r\n"}},{"0":"my-first-article.md","1":{"frontmatter":{"title":"My first article","date":"2022/07/23","description":"This is the description of my first article","featuredImage":"/static/images/jorg-angeli-CAMwIxYk5Xg-unsplash.jpg","tags":["HTML","CSS","JS","Node.js","Hono","Eta","Markdown"]},"content":"\r\nThis is the content of my first article\r\n"}}]